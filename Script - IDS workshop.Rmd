---
title: "Data wrangling at scale with data.table"
author: "Gresa Smolica & Amin Oueslati"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Before we start, what are we actually telling you about data.table speed? - Let's see: 
(example extracted by "EDAV Fall 2021 Tues/Thurs Community Contributions")
```{r}
## read a csv into a data.frame

start <- Sys.time()
df <- read.csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv")
end <- Sys.time()
print(end - start)
```


```{r}
## reading a csv into a tibble

pacman::p_load(data.table, learningtower, tidyverse)

start <- Sys.time()
tb <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv")
end <- Sys.time()
print(end - start)

```

```{r}
# reading a csv into a data.table

start <- Sys.time()
dt <- fread("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv")
end <- Sys.time()
print(end - start)
```

## Wrangling data at scale with data.table

To start getting into data.table and its operations, first we need to install and load the data.table package and the learningtower package - which provides easy access to a subset of variables from PISA data collected from the OECD, for the years 2000 - 2018. In this workshop we will use both student and school datasets. While the former contains data at the student-level, the latter has schools as units of observation.

```{r}
pacman::p_load(data.table, learningtower, tidyverse)

# load the student data for 2018
load_student("2018")

# load the school data for all years
data("school")
```

## Now, let's convert our dataset into data.table and assign it to an object to make working with the data easier:

```{r}
# assigning the datasets to objects
student_data <- as.data.table(load_student("2018"))
school_data <- as.data.table(school)

## let's inspect our datasets:
dim(student_data) # so our dataset has 612,004 rows/observations and 22 columns/variables. Awesome!
dim(school_data) # 109,756 rows and 13 columns. Great!
```

## Before we get into the wrangling, we need to keep in mind, data.table works through the following grammar:

DT[i, # where i shows "on which rows"
   j, # where j tells "what to do"
   by] # where by means "grouped by what?"

## Now, let's wrangle that data!

## Subsetting rows - working with "i" in data.table: Subsetting with data.table is quite straightforward. Let's say we want to subset all male students in Albania

```{r}
## sub-set all male students from Albania
male_albanian_students <- student_data[country == "ALB" & gender == "male"]
male_albanian_students

## as you can see, a comma after the condition in "i"is not required
## but student_data[country == "ALB" & gender == "male",] would work just fine
```
## Ordering rows in increasing or decreasing order | the power of (-) in data.table

```{r}
## order students in increasing order by their math score
incr_order <- male_albanian_students[order(math)]
incr_order[1:5]
```

```{r}
## order students in decreasing order by their math score
decr_ord <- male_albanian_students[order(-math)]
decr_ord[1:5]
```

## Special operator %between% and %inrange%. They are useful to subset rows conditional on a value falling within a certain range. The two operators accept both scalars and vectors. When used with a scalar, %between% and %inrange% perform identically However, both operators also accept vectors, in which case the operate differently.

```{r}
## when used with a scalar, %between% and %inrange% perform identically
between_scaler <- male_albanian_students[math %between% c(500, 600)]
inrange_scaler <- male_albanian_students[math %inrange% c(500, 600)]
length(between_scaler) == length(inrange_scaler)

## using %between% and %inrange% with vectors

# %between% evaluates each row and returns T/F if the value of interest falls between the two vectors - the range defined by the two vectors varies for each row
# check whether the math score of a given students falls between his/her reading and science score
between_vector <- male_albanian_studens[math %between% list(science, read)]
between_vector # 188 rows, more stringent selection criterion

# %inrange% takes the minimum from the lower-bound (first vector) and the maximum from the upper-bound (second vector), forms a static range and then evaluates whether the value in a given row falls within this range
# check whether the math score of a given student falls between the lowest science and highest reading score of ALL students
inrange_vector <- male_albanian_studens[math %inrange% list(science, read)]
inrange_vector # 3,182 rows, all students in the dataset
```


## Dealing with columns in data.table - working with "j". The logic is fairly straightforward, but there are two things to keep in mind: First, if we don't wrap j, R returns a vector. Second, if we want R to return a data.table (most of the time this is what we want!) we need to wrap j, either with list() or shorter .(). Let's see how both of the look:

```{r}
# returning a vector
student_id_vector <- student_data[, student_id] 
student_id_vector

# returning a data.table, wrapping with list()
select_columns <- student_data[, list(student_id, country, gender, read, science)]
select_columns

# returning a data.table, wrapping with .()
select_columns <- student_data[,.(student_id, country, gender, read, science)] 
select_columns[1:5]

# drop selected columns
select_columns_short <- select_columns[, !c("read", "science")]
select_columns_short
```

## Selecting and renaming columns with data.table:

```{r}
renamed_cols <- student_data[, .(books = book, socio_eco_status = escs)]
head(renamed_cols)
```

## Creating new columns with data.table: 

```{r}
# creating a new column which combines the reading and science scores
total_score <- male_albanian_students[, 
  total_score := read + science]
total_score
```

## How about creating multiple columns?

```{r}
# creating multiple new columns
multiple_columns <- school_data[ , `:=` (
  total_fun = fund_gov + fund_fees + fund_donation,  total_students = enrol_boys + enrol_girls)]
multiple_columns
```

## Descriptive analysis with data.table 

```{r}
# first we drop na-s to make our lives easier
clean_school_data <- na.omit(school_data)

# school with most enrolled boys
max_boys <- clean_school_data[, max(enrol_boys)]
max_boys

# school with fewest enrolled girls 
min_girls <- clean_school_data[, min(enrol_girls)]
min_girls

# adding logical operators: total enrolled boys exceeding enrolled girls
more_boys_than_girls <- clean_school_data[, sum(enrol_boys < enrol_girls)]
more_boys_than_girls

# further sub-setting and computing:
subseting_computing <- clean_school_data[country== "FRA" & year == 2018, sum(total_students)]
```

## Special symbol .N

```{r}
# this type of operation length () occurs quite frequently, especially while grouping, therefore we can do the following:
clean_school_data[country== "FRA" & year == 2018, length(school_size)] 

# special operator N
clean_school_data[country== "FRA" & year == 2018, .N]
# we see that we get the same result with 16 characters less! 
# but please keep in mind .N is a special built-in variable that holds the number of observations in the current group.
```

## Grouping with "by". By allows us to perform operations by group. We are not limited to a single group, but can specify several groups.

```{r}
# getting the total number of schools by country
group_country <- school_data[, .(.N), by = .(country)]
group_country

# conditional grouping: by also accepts conditional expressions, i.e., create groups around conditions. The outcome is a matrix which shows all possible true/false combinations
# compute the mean staff shortage for Albanian schools differentiated by (i) whether more than 50% of their funding comes from donations, (ii) whether a school's total number of students is below 500
by_condition <- clean_school_data[country == "ALB",
        .(mean(staff_shortage)),
        by = .(fund_donation > 50, total_students < 500)]
by_condition
```


## Descriptive analysis continued

```{r}
# let's try to subset both in columns and rows:
cols_rows <- clean_school_data[country == "FRA" & year == 2018,
               .(m_total = mean(total_students), m_fun = mean(total_fun))]
cols_rows

# combining all the operations we learnt so far
# compute the mean number of enrolled boys and girls in schools in Kazakhstan, grouped by year and private/public status 
all_combined <- clean_school_data[country == "KAZ",
        .(mean(enrol_boys), mean(enrol_girls)),
        by = .(year, public_private)]
all_combined
# why are we seeing V1, V2?
```

## Full-on data.table - Advanced operations. What if we need to repeat an operation across many columns, like finding the mean? Is there a way to calculate the mean for several columns at once? Yes, we can subset each column with .SD, and then compute the mean with with lapply. .SD is particularly useful in the context of grouping, where it refers to each of these sub-data.tables, one-at-a-time. If we want to limit the column-wise computation to selected columns only (e.g., only numerical ones), we specify these through .SDcols

```{r}
# repeated operations with .SD, .SDcols and lapply
# compute the mean of enrolled boys, enrolled girls and the share of funding from student fees (full percentage points) across countries in 2018
mean_columns <- c("enrol_boys", "enrol_girls", "fund_fees") 
# specifying the columns to iterate over
selected_means <- clean_school_data[year == 2018,        
        lapply(.SD, mean),                    
        by = .(country),           
        .SDcols = mean_columns]   
selected_means
```

## Chaining in data.table. To avoid saving intermediate results, data.table uses chaining (pipe-operator in tidyverse). The syntax can be read as ‘result from first []-operation is used in subsequent []-operation’. Chaining vertically enhances readability


```{r}
# chaining vertically as best practice
DT[...
    ][...
      ][...
        ]

# chaining operations together
# computing the mean staff shortage by country and then ordering the result in decreasing order
chaining <- clean_school_data[,
                              .(staff_shortage = mean(staff_shortage)), 
                              by = .(country)
                  ][order(-staff_shortage)
                    ]
chaining
```

