---
title: "Data wrangling at scale with data.table"
author: "Gresa Smolica & Amin Oueslati"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Before we start, what are we actually telling you about data.table speed?? - Let's see: 
(example extracted by "EDAV Fall 2021 Tues/Thurs Community Contributions")
```{r}
## read a csv into a data.frame

start <- Sys.time()
df <- read.csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv")
end <- Sys.time()
print(end - start)
```


```{r}
## reading a csv into a tibble

start <- Sys.time()
tb <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv")
end <- Sys.time()
print(end - start)

```

```{r}
# reading a csv into a data.table

start <- Sys.time()
dt <- fread("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv")
end <- Sys.time()
print(end - start)

```

## Wrangling data at scale with data.table

To start getting our hands into data.table and its operations, first we need to install and load the data.table package and the learningtower package - which provides easy access to a subset of variables from PISA data collected from the OECD, for the years 2000 - 2018. 

As per usual steps, after installing, we also need to load both packages to start working through them. Considering the big datasets within learningtower package, for this exercise we will use only the Student Dataset:

```{r}
install.packages("data.table")
install.packages("learningtower")
library(data.table)
library(learningtower)
load_student("2018")
data("school")
library(tidyverse)

```

## Now, let's convert our dataset into data.table and assign it to an object to operate more easily:

```{r}
student_data <- as.data.table(load_student("2018"))

school_data <- as.data.table(school)

## Let's see what's inside our datasets:
dim(student_data) # so our dataset has 612,004 rows/observations and 22 columns/variables. Awesome!

dim(school_data) # 109,756 rows and 13 columns. Great!

```

## Before we get into the wrangling, we need to keep in mind, data.table works through the following grammar:

```{r}
DT[i, # where i shows "on which rows"
   j, # where j tells "what to do"
   by] # where by means "grouped by what?"

## or put in a sentence: take DT, subset ( or order) rows using "i", then calculate "j", and group by "by"
```

## Now, let's wrangle that data!

## Subsetting rows - working with "i" in data.table: Subsetting with data.table is quite straightforward. Let's say we want to subset all the students in Albania that don't have internet access: 

```{r}
sub_1 <- student_data [country == "ALB" & internet == "no"]

## as you can see, a comma after the condition in "i" is not required due to the i,j,by order.
```
## Getting the first four rows from student_data:

```{r}
student_data [1:4]
```
## Ordering rows in increasing or decreasing order | the power of (-) in data.table

```{r}
incr_ord <- student_data[order(country, math)]
```


```{r}

decr_ord <- student_data[order(country, -math)]
```

## Dealing with colums in data.table - working with "j" : the similar logic follows when extracting or selecting a column, however two things to keep in mind: first if we just put the column name the function returns us a vector, second if we want to return us a data.table (most of the time this is what we want!) we need to use () around our column/variable. Let's see how both of the look:

```{r}
student_data [, student_id] # returning a vector

student_data [, list(gender, science)] # returning us a data.table

student_data [, .(gender, math)] # a short version where .() instead of list() returns us a data.table

student_data [, !list(car, dishwasher, television, computer_n)]
```

## Selecting and renaming columns with data.table:

```{r}

renamed_cols <- student_data[, .(books = book, socio_eco_status = escs)]
head(renamed_cols)
```

## Creating new columns with data.table: 

```{r}

total_science <- student_data[, total_science := math + science]

```

## How about creating multiple columns?
```{r}
view(school_data[ , `:=` (total_fun = fund_gov + fund_fees + fund_donation, total_students = enrol_boys + enrol_girls)])
```

## Grouping by "by":

```{r}
# how can we know how many entries per country do we have?
group_country <- school_data[, .(.N), by = .(country)]

```

## Computing with data.table: 

```{r}
# first we drop na-s to allow us better computing:
clean_school_data <- na.omit(school_data)
 

# Logical operators and computing?
computing <- clean_school_data[, sum (enrol_boys < enrol_girls)]

#further subsetting and computing:

subseting_computing <- clean_school_data[country== "FRA" & year == 2018, sum(total_students)]
```

## Descriptive analysis

```{r}
# let's try to subset both in columns and rows:
cols_rows <- clean_school_data[country == "FRA" & year == 2018,
               .(m_total = mean(total_students), m_fun = mean(total_fun))]

# we have a special symbol .N in data.table..let's see what it does:

clean_school_data[country== "FRA" & year == 2018, length(school_size)] # this type of operation length () occurs quite frequently, especially while grouping, therefore we can do the following:

clean_school_data[country== "FRA" & year == 2018, .N] # we see that we get the same result with 16 characters less! (but please keep in mind .N is a special built-in variable that holds the number of observations in the current group.)

# using all the operations learned so far:
clean_school_data[country == "KAZ",
        .(mean(enrol_boys), mean(enrol_girls)),
        by = .(year, public_private)]

# why are we seeing V1, V2?


##clean_school_data[country == "KAZ",
##        .(mean_boys = mean(enrol_boys), mean_girls = mean(enrol_girls)),
##        by = .(year, public_private)]

```

## Full-on data.table - Advanced operations

```{r}
# How can we calculate more efficiently? Finding the mean is an usual and very frequent operation in R. Is there a way to calculate the mean for several columns at once? Yes, and it is called - .SD:

clean_school_data[country == "KAZ",                      
        lapply(.SD, mean),                    
        by = .(year),           
        .SDcols = c("enrol_boys", "enrol_girls")]   # for the spcified columns. .SD can work also on one column or a more simple operation, however .SDcols is superior is making the calculations fasters for a larger group of data.
```


```{r}
# What would if we do if we had to subset some columns and the order/arrange those columns? the first most obvious would be to first subset, and then take the result and work on it for the second task. However data.table allows us to avoid overwriting on the result, by chaining expressions:

clean_school_data[country == "LTU", .N, by = .(enrol_boys, enrol_girls)
                  ][order(enrol_boys, -enrol_girls)
                    ]

```

